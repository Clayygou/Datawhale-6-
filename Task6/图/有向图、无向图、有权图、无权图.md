## 实现有向图、无向图、有权图、无权图的邻接矩阵和邻接表表示方法。

### 代码（有向图-邻接表）
```p
class DirectedGraph(object):
    def __init__(self,d):
        if isinstance(d,dict):
            self.__graph = d
        else:
            self.__graph = dict()
            raise KeyError("NO Input")

    def add(self,f,e):
    	self.__graph[f].append(e)
    	print(self.__graph)
    def delete(self,f,e):
    	self.__graph[f].remove(e)
    	print(self.__graph)


    def __generatePath(self,graph,path,end,results):
        #深度优先搜索 一条一条路径的找
        curret = path[-1]
        if curret == end:
            results.append(path)
        else:
            for n in graph[curret]:
                #找到从当前点出发指向的点
                if n not in path:
                    self.__generatePath(graph,path+[n],end,results)

    def searchPath(self,start,end):
        self.__results = []
        self.__generatePath(self.__graph,[start],end,self.__results)
        self.__results.sort(key=lambda  x:len(x))   
        #按所有路径的长度进行排序
        print('The path from ',self.__results[0][0],'to',self.__results[0][-1],'is:')
        for path in self.__results:
            print(path)

if __name__ == '__main__':
	d={'A':['B','C','D'],
	    'B':['E'],
	    'C':['D','F'],
	    'D':['B','E','G'],
	    'E':['D'],
	    'F':['D','G'],
	    'G':['E']}
	g=DirectedGraph(d)
	g.add('A','E')
	g.delete("A","E")
	g.searchPath('A','E')

	'''result
	The path from  A to E is:
	['A', 'B', 'E']
	['A', 'D', 'E']
	['A', 'C', 'D', 'E']
	['A', 'D', 'B', 'E']
	['A', 'D', 'G', 'E']
	['A', 'C', 'D', 'B', 'E']
	['A', 'C', 'D', 'G', 'E']
	['A', 'C', 'F', 'D', 'E']
	['A', 'C', 'F', 'G', 'E']
	['A', 'C', 'F', 'D', 'B', 'E']
	['A', 'C', 'F', 'D', 'G', 'E']
	'''
```

### 代码（有向图-邻接矩阵）
```p
import numpy as np 
class DirectedGraph_jz(object):
	"""docstring for DirectedGraph_jz"""
	def __init__(self):
		self.__graph1 = {}  
		# self.g = {}
			 
	def create_jzt(self,arr):
		for i in range(len(arr)):
			for j in range(len(arr)):
				if arr[i][j] == 1:
					self.add_edge(i, j)		

	def add_edge(self,i,j):
		if i in self.__graph1.keys():
			self.__graph1[i].append(j)
		else:
			self.__graph1[i] = [j]
	def show(self):
		print(self.__graph1)
			

if __name__ == '__main__':
	g1 = DirectedGraph_jz()
	Matrix = np.array(
	[	[0, 1, 1, 1, 1, 1, 0, 0],
		[0, 0, 1, 0, 1, 0, 0, 0],
		[0, 0, 0, 1, 0, 0, 0, 0],
		[0, 0, 0, 0, 1, 0, 0, 0],
		[0, 0, 0, 0, 0, 1, 0, 0],
		[0, 0, 1, 0, 0, 0, 1, 1],
		[0, 0, 0, 0, 0, 1, 0, 1],
		[0, 0, 0, 0, 0, 1, 1, 0]])
	g1.create_jzt(Matrix)
	g1.show()  # {0: [1, 2, 3, 4, 5], 1: [2, 4], 2: [3], 3: [4], 4: [5], 5: [2, 6, 7], 6: [5, 7], 7: [5, 6]}
	# print(g1.__graph1)
	# print(g1.g)

# #利用networkx也可以方便的构建邻接矩阵表示的图
# import networkx as nx
# import matplotlib.pyplot as plt
 
# G = nx.Graph()
# Matrix = np.array(
#     [
#         [0, 1, 1, 1, 1, 1, 0, 0],  # a
#         [0, 0, 1, 0, 1, 0, 0, 0],  # b
#         [0, 0, 0, 1, 0, 0, 0, 0],  # c
#         [0, 0, 0, 0, 1, 0, 0, 0],  # d
#         [0, 0, 0, 0, 0, 1, 0, 0],  # e
#         [0, 0, 1, 0, 0, 0, 1, 1],  # f
#         [0, 0, 0, 0, 0, 1, 0, 1],  # g
#         [0, 0, 0, 0, 0, 1, 1, 0]  # h
#     ]
# )
# for i in range(len(Matrix)):
#     for j in range(len(Matrix)):
#         G.add_edge(i, j)
 
# nx.draw(G)
# plt.show()
```
### 总结
利用字典实现邻接表和邻接矩阵表示的有向无权图。
